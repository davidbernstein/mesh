/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #include "polygon.h"#include "constants.h"#include <iostream>using namespace NAMESPACE;using namespace std;void Polygon::OutwardAreaNormal(Array<Point> &unitNormal) const{	return;}double Polygon::Area() const{	// this works for polygons oriented both clockwise (sum < 0)	// and counterclockwise (sum > 0)	// doesn't work for self-intersecting polygons or polygons with holes	// assumes polygon lies in a Z=constant plane		double sum = 0.0;		short numVertices = NumVertices();	short i;	for (i = 0; i < numVertices - 1; ++i) 		sum += mpVertex[i]->X() * mpVertex[i+1]->Y() - mpVertex[i+1]->X() * mpVertex[i]->Y();		i = numVertices - 1;	sum += mpVertex[i]->X() * mpVertex[0]->Y() - mpVertex[0]->X() * mpVertex[i]->Y();		return 0.5 * fabs(sum);}bool Polygon::operator==(const Polygon &p) const{	ThrowException("Polygon::operator== called");	return false;}bool Polygon::operator<(const Polygon &p) const{	ThrowException("Polygon::operator< called");	return false;}bool Polygon::operator>(const Polygon &p) const{	ThrowException("Polygon::operator> called");	return false;}bool Polygon::operator!=(const Polygon &p) const{	ThrowException("Polygon::operator!= called");	return false;}