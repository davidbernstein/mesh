/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #include "tetrahedron.h"#include "realmatrix.h"#include "triangle.h"#include <iostream>using namespace NAMESPACE;using namespace std;void Tetrahedron::Bisect(Element *pChild[2], Vertex *pVMid){	BisectionData *pBD = GetBisectionData();	BisectionData *pBD0 = pChild[0]->GetBisectionData();	BisectionData *pBD1 = pChild[1]->GetBisectionData();		pBD0->SetParent(this);	pBD1->SetParent(this);	pBD->SetChildren(pChild[0], pChild[1]);    	// get refinement edge vertices	Vertex *pV[2];	GetEdge(pBD->RefinementEdge(), pV);		// get opposite vertices	Vertex *pVOpp[2];	short j = 0;	for (short i = 0; i < NumVertices(); ++i) {		if ((PV(i) != pV[0]) && (PV(i) != pV[1])) {			pVOpp[j] = PV(i);			++j;		}	}		// set child vertices		pChild[0]->SetVertices(pV[0], pVMid, pVOpp[0], pVOpp[1]);	pChild[1]->SetVertices(pV[1], pVMid, pVOpp[0], pVOpp[1]);		// set all neighbors	pChild[0]->SetNeighbor(0, pChild[1]);	pChild[1]->SetNeighbor(0, pChild[0]);	    BisectionData *pBDN;    Element *pChildN[2];        // neighbor on first nonrefinement face	short faceIndex = FaceIndex(pV[0], pVOpp[0], pVOpp[1]);	Element *pN = PN(faceIndex);	pChild[0]->SetNeighbor(1, pN);	if (pN->Type() != BLOB) {        pN->ReplaceNeighbor(this, pChild[0], true);        pBDN = pN->GetBisectionData();        if (pBDN->IsALeaf() == false) {            pBDN->GetChildren(pChildN);            pChildN[0]->ReplaceNeighbor(this, pChild[0], true);            pChildN[1]->ReplaceNeighbor(this, pChild[0], true);        }    }        // neighbor on second nonrefinement face	faceIndex = FaceIndex(pV[1], pVOpp[0], pVOpp[1]);    pN = PN(faceIndex);	pChild[1]->SetNeighbor(1, pN);    if (pN->Type() != BLOB) {        pN->ReplaceNeighbor(this, pChild[1], true);        pBDN = pN->GetBisectionData();        if (pBDN->IsALeaf() == false) {            pBDN->GetChildren(pChildN);            pChildN[0]->ReplaceNeighbor(this, pChild[1], true);            pChildN[1]->ReplaceNeighbor(this, pChild[1], true);        }	}        // neighbor on first refinement face        faceIndex = FaceIndex(pV[0], pV[1], pVOpp[0]);    pN = PN(faceIndex);    if (pN->Type() == BLOB) {    	pChild[0]->SetNeighbor(3, pN);		pChild[1]->SetNeighbor(3, pN);    }    else {    	pBDN = pN->GetBisectionData();    	if (pBDN->IsALeaf()) {    		pChild[0]->SetNeighbor(3, pN);			pChild[1]->SetNeighbor(3, pN);    	}    	else {    		// make sure neighbor is actually split along this face    		Vertex *pVTmp[2];    		pN->GetEdge(pBDN->RefinementEdge(), pVTmp);    		for (short k = 0; k < 2; ++k) {    			if ((pVTmp[k] != pV[0]) && (pVTmp[k] != pV[1]) && (pVTmp[k] != pVOpp[0]))    				ThrowException("blah");    		}    		    		pBDN->GetChildren(pChildN);			faceIndex = pChildN[0]->FaceIndex(pV[0], pVMid, pVOpp[0]);			if (faceIndex != -1) {				pChild[0]->SetNeighbor(3, pChildN[0]);				pChildN[0]->ReplaceNeighbor(this, pChild[0], true);				pChild[1]->SetNeighbor(3, pChildN[1]);				pChildN[1]->ReplaceNeighbor(this, pChild[1], true);			}			else {				pChild[0]->SetNeighbor(3, pChildN[1]);				pChildN[0]->ReplaceNeighbor(this, pChild[1], true);				pChild[1]->SetNeighbor(3, pChildN[0]);				pChildN[1]->ReplaceNeighbor(this, pChild[0], true);			}    	}    }        // neighbor on second refinement face    faceIndex = FaceIndex(pV[0], pV[1], pVOpp[1]);    pN = PN(faceIndex);    if (pN->Type() == BLOB) {    	pChild[0]->SetNeighbor(2, pN);		pChild[1]->SetNeighbor(2, pN);    }    else {    	pBDN = pN->GetBisectionData();    	if (pBDN->IsALeaf()) {			pChild[0]->SetNeighbor(2, pN);			pChild[1]->SetNeighbor(2, pN);    	}    	else {			pBDN->GetChildren(pChildN);			faceIndex = pChildN[0]->FaceIndex(pV[0], pVMid, pVOpp[1]);			if (faceIndex != -1) {				pChild[0]->SetNeighbor(2, pChildN[0]);				pChildN[0]->ReplaceNeighbor(this, pChild[0], true);				pChild[1]->SetNeighbor(2, pChildN[1]);				pChildN[1]->ReplaceNeighbor(this, pChild[1], true);			}			else {				pChild[0]->SetNeighbor(2, pChildN[1]);				pChildN[0]->ReplaceNeighbor(this, pChild[1], true);				pChild[1]->SetNeighbor(2, pChildN[0]);				pChildN[1]->ReplaceNeighbor(this, pChild[0], true);			}    	}    }			return;}short Tetrahedron::FaceIndex(const Vertex *pV0, const Vertex *pV1, const Vertex *pV2) const{	short i0 = WhichVertex(pV0);	short i1 = WhichVertex(pV1);	short i2 = WhichVertex(pV2);		if ((i0 == -1) || (i1 == -1) || (i2 == -1))		return -1;		for (short i = 0; i < NumNeighbors(); ++i) {		if ((i0 != i) && (i1 != i) && (i2 != i))			return i;	}		// can't get here	ThrowException("Tetrahedron::FaceIndex : can't get here");	return -1;}double Tetrahedron::Volume() const{	static double factor = 1.0 / 6.0;		Point p01 = *PV(1) - *PV(0);	Point p02 = *PV(2) - *PV(0);	Point p03 = *PV(3) - *PV(0);		return factor * fabs(p03.Dot(p01.Cross(p02)));}double Tetrahedron::Area(void) const{    Triangle triangle;    Array<Vertex*> pV(3);        double sum = 0.0;    for (short j = 0; j < NumNeighbors(); ++j) {        GetFace(j, pV);        triangle.SetVertices(pV[0], pV[1], pV[2]);        sum += triangle.Area();    }        return sum;}void Tetrahedron::FaceArea(Array<double> &faceArea) const{    faceArea.SetSize(4);        Triangle triangle;    Array<Vertex*> pV(3);        short j;    for (j = 0; j < NumNeighbors(); ++j) {        GetFace(j, pV);        triangle.SetVertices(pV[0], pV[1], pV[2]);        faceArea[j] = triangle.Area();    }        return;}bool Tetrahedron::ContainsPoint(const Point &p) const{    Array<double> b(4);    BarycentricCoordinates(p, b);    return ((b[0] > 0.0) && (b[1] > 0.0) && (b[2] > 0.0) && (b[3] > 0.0));}void Tetrahedron::BarycentricCoordinates(const Point &p, Array<double> &b) const{    b.SetSize(4);        double d0 = BarycentricDeterminate(p);       b[0] = BarycentricDeterminate(p, 0) / d0;    b[1] = BarycentricDeterminate(p, 1) / d0;         b[2] = BarycentricDeterminate(p, 2) / d0;    b[3] = 1.0 - b[0] - b[1] - b[2];        return;}double Tetrahedron::BarycentricDeterminate(const Point &p, short index) const{    Matrix<double> m(4, 4);        m(0, 0) = PV(0)->X();    m(1, 0) = PV(1)->X();    m(2, 0) = PV(2)->X();    m(3, 0) = PV(3)->X();        m(0, 1) = PV(0)->Y();    m(1, 1) = PV(1)->Y();    m(2, 1) = PV(2)->Y();    m(3, 1) = PV(3)->Y();        m(0, 2) = PV(0)->Z();    m(1, 2) = PV(1)->Z();    m(2, 2) = PV(2)->Z();    m(3, 2) = PV(3)->Z();        m(0, 3) = 1.0;    m(1, 3) = 1.0;    m(2, 3) = 1.0;    m(3, 3) = 1.0;        switch (index) {    case 0:        m(0, 0) = p.X();        m(0, 1) = p.Y();        m(0, 2) = p.Z();        break;            case 1:        m(1, 0) = p.X();        m(1, 1) = p.Y();        m(1, 2) = p.Z();        break;        case 2:        m(2, 0) = p.X();        m(2, 1) = p.Y();        m(2, 2) = p.Z();        break;            case 3:        m(3, 0) = p.X();        m(3, 1) = p.Y();        m(3, 2) = p.Z();        break;    }        return m.Determinant();}void Tetrahedron::Orient(){	Point p01 = *PV(1) - *PV(0);	Point p02 = *PV(2) - *PV(0);	Point p03 = *PV(3) - *PV(0);		if (p03.Dot((p01.Cross(p02))) < 0.0) 		SetVertices(PV(0), PV(2), PV(1), PV(3));		return;}bool Tetrahedron::Oriented() const{	Point p01 = *PV(1) - *PV(0);	Point p02 = *PV(2) - *PV(0);	Point p03 = *PV(3) - *PV(0);		return p03.Dot((p01.Cross(p02))) > 0.0;}bool Tetrahedron::operator==(const Tetrahedron &t) const{	ThrowException("Tetrahedron::operator== called");	return false;}bool Tetrahedron::operator<(const Tetrahedron &t) const{	ThrowException("Tetrahedron::operator< called");	return false;}bool Tetrahedron::operator>(const Tetrahedron &t) const{	ThrowException("Tetrahedron::operator> called");	return false;}bool Tetrahedron::operator!=(const Tetrahedron &t) const{	ThrowException("Tetrahedron::operator!= called");	return false;}