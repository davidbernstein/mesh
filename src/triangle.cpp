/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #include "triangle.h"#include "constants.h"#include <iostream>using namespace NAMESPACE;using namespace std;void Triangle::Bisect(Element *pChild[2], Vertex *pVMid){	BisectionData *pBD = GetBisectionData();	BisectionData *pBD0 = pChild[0]->GetBisectionData();	BisectionData *pBD1 = pChild[1]->GetBisectionData();		pBD0->SetParent(this);	pBD1->SetParent(this);	pBD->SetChildren(pChild[0], pChild[1]);    	// get opposite vertex	short refEdge = pBD->RefinementEdge();	Vertex *pV[2];	GetEdge(refEdge, pV);	short i = 0;	while ((PV(i) == pV[0]) || (PV(i) == pV[1]))		++i;				Vertex *pOpposite = PV(i);					pChild[0]->SetVertices(pOpposite, pV[0], pVMid);	pChild[1]->SetVertices(pOpposite, pVMid, pV[1]);		// set neighbors	pChild[0]->SetNeighbor(1, pChild[1]);	pChild[1]->SetNeighbor(2, pChild[0]);        // neighbor on first nonrefinement edge	short faceIndex = FaceIndex(pOpposite, pV[0]);    Element *pN = PN(faceIndex);	pChild[0]->SetNeighbor(2, pN);	if (pN->Type() != BLOB) {        pN->SetNeighbor(pN->FaceIndex(pOpposite, pV[0]), pChild[0]);    }        // neighbor on second nonrefinement edge	faceIndex = FaceIndex(pOpposite, pV[1]);    pN = PN(faceIndex);	pChild[1]->SetNeighbor(1, pN);    if (pN->Type() != BLOB) {        pN->SetNeighbor(pN->FaceIndex(pOpposite, pV[1]), pChild[1]);	}        // refinement edge neighbors    pN = PN(refEdge);    if (pN->Type() == BLOB) {    	pChild[0]->SetNeighbor(0, pN);		pChild[1]->SetNeighbor(0, pN);    }    else {    	BisectionData *pBDN = pN->GetBisectionData();    	if (pBDN->IsALeaf() == false) {			// this is the case in which PN(n) is already bisected along 			// the refinement edge			Element *pChildN[2];			pBDN->GetChildren(pChildN);					faceIndex = pChildN[0]->FaceIndex(pV[0], pVMid);			if (faceIndex != -1) {				pChild[0]->SetNeighbor(0, pChildN[0]);				pChild[1]->SetNeighbor(0, pChildN[1]);				pChildN[0]->SetNeighbor(faceIndex, pChild[0]);				pChildN[1]->SetNeighbor(pChildN[1]->FaceIndex(pV[1], pVMid), pChild[1]);			}			else {            	faceIndex = pChildN[0]->FaceIndex(pV[1], pVMid);            	if (faceIndex == -1) {            		short x = pChildN[0]->FaceIndex(pV[1], pV[0]);            		short y = pChildN[0]->FaceIndex(pV[1], pOpposite);            		short z = pChildN[0]->FaceIndex(pOpposite, pV[0]);            		ThrowException("");            	}				pChild[0]->SetNeighbor(0, pChildN[1]);				pChild[1]->SetNeighbor(0, pChildN[0]);				pChildN[0]->SetNeighbor(faceIndex, pChild[1]);				pChildN[1]->SetNeighbor(pChildN[1]->FaceIndex(pV[0], pVMid), pChild[0]);			}		}	}		return;}Vertex* Triangle::EdgeMidPoint(short index) const{	Vertex *pV[2];	GetEdge(index, pV);		Element *pN = PN(index);	BisectionData *pBDn = pN->GetBisectionData();		if (pBDn->IsALeaf()) {		return NULL;	}	else {		// find midpoint		Element *pChild[2];		pBDn->GetChildren(pChild);		short i = 0;		while (pN->IsAVertex(pChild[0]->PV(i))) 			++i;				return pChild[0]->PV(i);	}}Vertex* Triangle::Merge(Element *pSibling, Element *pParent){    // find midpoint vertex    Vertex *pV = NULL;    for (short i = 0; i < NumVertices(); ++i) {        if (pParent->IsAVertex(PV(i)) == false)            pV = PV(i);    }        if (pV == NULL)        ThrowException("Triangle::Merge : didn't find midpoint vertex");            // determine if pV is isolated    short count = 0;    for (short i = 0; i < NumNeighbors(); ++i)         count += (short) PN(i)->IsAVertex(pV);            // fix neighbors    Vertex *pVn[2];    for (short i = 0; i < NumNeighbors(); ++i) {        PN(i)->ReplaceNeighbor(this, pParent);        GetEdge(i, pVn);        short faceIndex = pParent->FaceIndex(pVn[0], pVn[1]);        if (faceIndex != -1)            pParent->SetNeighbor(faceIndex, PN(i));    }        for (short i = 0; i < pSibling->NumNeighbors(); ++i) {        pSibling->PN(i)->ReplaceNeighbor(pSibling, pParent);        pSibling->GetEdge(i, pVn);        short faceIndex = pParent->FaceIndex(pVn[0], pVn[1]);        if (faceIndex != -1)            pParent->SetNeighbor(faceIndex, pSibling->PN(i));    }        // need to set neighbor of parent on refinement edge side        pParent->GetBisectionData()->EraseChildren();        if (count == 1)        return pV;    else        return NULL;}void Triangle::FaceArea(Array<double> &faceArea) const{    faceArea.SetSize(NumNeighbors());    Vertex *pV[2];            for (short j = 0; j < faceArea.Size(); ++j) {        GetEdge(j, pV);        faceArea[j] = pV[0]->DistanceToPoint(pV[1]);    }        return;}void Triangle::OutwardAreaNormal(Array<Point> &unitNormal) const{	unitNormal.SetSize(NumNeighbors());		Point areaNormal;	AreaNormal(areaNormal);	areaNormal.Normalize();		Vertex *pV[2];            for (short j = 0; j < unitNormal.Size(); ++j) {        GetEdge(j, pV);        unitNormal[j] = areaNormal.Cross(*pV[0] - *pV[1]);    }		return;}bool Triangle::ContainsPoint(const Point &p) const{    // this function assumes that this triangle is located in the X-Y plane    // the Z coordinate of p is ignored        double a = (PV(1)->X() - PV(0)->X()) * (p.Y() - PV(0)->Y())              - (PV(1)->Y() - PV(0)->Y()) * (p.X() - PV(0)->X());                 double b = (PV(2)->X() - PV(1)->X()) * (p.Y() - PV(1)->Y())              - (PV(2)->Y() - PV(1)->Y()) * (p.X() - PV(1)->X());                 double c = (PV(0)->X() - PV(2)->X()) * (p.Y() - PV(2)->Y())              - (PV(0)->Y() - PV(2)->Y()) * (p.X() - PV(2)->X());        if (a >= 0.0)         return (b >= 0.0) & (c >= 0.0);    else        return (b < 0.0) & (c < 0.0);    /*     13 Sep 2003 03:38:38 -0700          What is the best algorithm of detecting whether the point is within     triangle(given with 3 points)?          I use the vector product: there is a triangle (x1, y1, x2, y2, x3, y3)     and a point (x, y); then     a = (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1);     b = (x3 - x2) * (y - y2) - (y3 - y2) * (x - x2);     c = (x1 - x3) * (y - y3) - (y1 - y3) * (x - x3);     if a, b and c have the same sign ("+" or "-"), then the point is     within the triangle, if they have different signs, then it is untrue.    */}bool Triangle::operator==(const Triangle &t) const{	ThrowException("Triangle::operator== called");	return false;}bool Triangle::operator<(const Triangle &t) const{	ThrowException("Triangle::operator< called");	return false;}bool Triangle::operator>(const Triangle &t) const{	ThrowException("Triangle::operator> called");	return false;}bool Triangle::operator!=(const Triangle &t) const{	ThrowException("Triangle::operator!= called");	return false;}