/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #include "brick.h"#include "triangle.h"#include <iostream>using namespace NAMESPACE;using namespace std;short Brick::FaceIndex(const Vertex *pV0, const Vertex *pV1, const Vertex *pV2) const{	ThrowException("Brick::FaceIndex : not implemented");	short i0 = WhichVertex(pV0);	short i1 = WhichVertex(pV1);	short i2 = WhichVertex(pV2);		if ((i0 == -1) || (i1 == -1) || (i2 == -1))		return -1;		for (short i = 0; i < NumNeighbors(); ++i) {		if ((i0 != i) && (i1 != i) && (i2 != i))			return i;	}		// can't get here	ThrowException("Brick::FaceIndex : can't get here");	return -1;}double Brick::Volume() const{	// currently works only for orthogonal bricks		Point p01 = *PV(1) - *PV(0);	Point p03 = *PV(3) - *PV(0);	Point p04 = *PV(4) - *PV(0);		return p01.Norm() * p03.Norm() * p04.Norm();}double Brick::Area(void) const{	Array<double> faceArea;	FaceArea(faceArea);        double sum = 0.0;    for (short j = 0; j < faceArea.Size(); ++j)         sum += faceArea[j];        return sum;}void Brick::FaceArea(Array<double> &faceArea) const{	// currently works only for orthogonal bricks    faceArea.SetSize(6);        Triangle triangle;    Array<Vertex*> pV(3);        short j;    for (j = 0; j < NumNeighbors(); ++j) {        GetFace(j, pV);        triangle.SetVertices(pV[0], pV[1], pV[2]);        faceArea[j] = 2.0 * triangle.Area();    }            return;}bool Brick::operator==(const Brick &b) const{	ThrowException("Brick::operator== called");	return false;}bool Brick::operator<(const Brick &b) const{	ThrowException("Brick::operator< called");	return false;}bool Brick::operator>(const Brick &b) const{	ThrowException("Brick::operator> called");	return false;}bool Brick::operator!=(const Brick &b) const{	ThrowException("Brick::operator!= called");	return false;}