/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #ifndef _tetrahedron_h_#define _tetrahedron_h_#include "element.h"namespace NAMESPACE {	class Tetrahedron : public Element {	public:		Tetrahedron(void);        ~Tetrahedron(void) {DeleteListIterator();};                		// type		ElementType Type(void) const{return TETRAHEDRON;};		short NumVertices(void) const {return 4;};				// vertices		void Orient(void);		bool Oriented() const;				// neighbors		short NumNeighbors(void) const {return 4;};				// bisection		void Bisect(Element *pChild[2], Vertex *pVNew);				// list iterator		void MakeListIterator(void *pListIterator);        void DeleteListIterator(void);                		// edges		short NumEdges(void) const {return 6;};		void GetEdge(short index, Vertex *pV[2]) const;		short EdgeIndex(const Vertex *pV0, const Vertex *pV1) const;				// faces		void GetFace(short index, Array<Vertex*> &pV) const;		short FaceIndex(const Vertex *pV0, const Vertex *pV1 = NULL, const Vertex *pV2 = NULL) const;				// geometry		double Volume(void) const;        double Area(void) const;        void FaceArea(Array<double> &faceArea) const;        bool ContainsPoint(const Point &p) const;        void BarycentricCoordinates(const Point &p, Array<double> &b) const;        short Dimension(void) const {return 3;};		// operators needed by STL		bool operator==(const Tetrahedron &t) const;		bool operator<(const Tetrahedron &t) const;		bool operator!=(const Tetrahedron &t) const;		bool operator>(const Tetrahedron &t) const;            private:        double BarycentricDeterminate(const Point &p, short index = -1) const;	};				inline Tetrahedron::Tetrahedron()	{		AllocateVertexArray();		return;	}				inline void Tetrahedron::GetEdge(short index, Vertex *pV[2]) const	{		switch (index) {		case 0:			pV[0] = PV(0);			pV[1] = PV(1);			break;					case 1:			pV[0] = PV(0);			pV[1] = PV(2);			break;					case 2:			pV[0] = PV(0);			pV[1] = PV(3);			break;					case 3:			pV[0] = PV(1);			pV[1] = PV(2);			break;					case 4:			pV[0] = PV(1);			pV[1] = PV(3);			break;					case 5:			pV[0] = PV(2);			pV[1] = PV(3);			break;				default:			ThrowException("Tetrahedron::GetEdge : bad index");			break;			}				return;	}				inline short Tetrahedron::EdgeIndex(const Vertex *pV0, const Vertex *pV1) const	{		short i0 = WhichVertex(pV0);		short i1 = WhichVertex(pV1);				if ((i0 == i1) || (i0 == -1) || (i1 == -1))			return -1;				if (i0 > i1)			std::swap(i0, i1);				// this trick happens to work with the edge numbering above		if (i0 == 0) 			return i1 - 1;				if (i0 == 1)			return i1 + 1;				return 5;	}				inline void Tetrahedron::GetFace(short index, Array<Vertex*> &pV) const	{		// faces are stored in the following order:		// face[0] is opposite to vertices 1-2-3		// face[1] is opposite to vertices 0-2-3		// face[2] is opposite to vertices 0-1-3		// face[3] is opposite to vertices 0-1-2				pV.SetSize(3);		        switch (index) {        case 0:            pV[0] = PV(1);            pV[1] = PV(3);            pV[2] = PV(2);            break;                case 1:            pV[0] = PV(0);            pV[1] = PV(2);            pV[2] = PV(3);            break;                case 2:            pV[0] = PV(0);            pV[1] = PV(3);            pV[2] = PV(1);            break;                case 3:            pV[0] = PV(0);            pV[1] = PV(1);            pV[2] = PV(2);            break;                default:            ThrowException("Tetrahedron::Face : bad face index");            break;        }        		return;	}				inline void Tetrahedron::MakeListIterator(void *pListIterator)	{        if (mpListIterator != NULL)             ThrowException("Tetrahedron::MakeListIterator : already on a list");                        std::list<Tetrahedron>::iterator *pLi = new std::list<Tetrahedron>::iterator;        *pLi = *(std::list<Tetrahedron>::iterator *) pListIterator;        mpListIterator = (std::list<Tetrahedron>::iterator *) pLi;		return;	}                        inline void Tetrahedron::DeleteListIterator()    {        delete ((std::list<Tetrahedron>::iterator *) mpListIterator);        return;    }}#endif // _tetrahedron_h_