/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #ifndef _polygon_h_#define _polygon_h_#include "element.h"namespace NAMESPACE {	class Polygon : public Element {	public:		// constructors		Polygon(void);        ~Polygon(void) {DeleteListIterator();};				// type		ElementType Type(void) const {return POLYGON;};				// vertoces		short NumVertices(void) const;				// neighbors		short NumNeighbors(void) const;				// edges		short NumEdges(void) const;		void GetEdge(short index, Vertex *pV[2]) const;		short EdgeIndex(const Vertex *pV0, const Vertex *pV1) const; 				// faces		void GetFace(short index, Array<Vertex*> &pV) const;		short FaceIndex(const Vertex *pV0, const Vertex *pV1 = NULL, const Vertex *pV2 = NULL) const;				// list iterator		void MakeListIterator(void *pListIterator);		void DeleteListIterator(void);                		// geometry		double Area(void) const;		double Volume(void) const;        void FaceArea(Array<double> &faceArea) const;        void OutwardAreaNormal(Array<Point> &unitNormal) const;        void AreaNormal(Point &areaNormal) const;        short Dimension(void) const {return 2;};				// operators needed by STL		bool operator==(const Polygon &p) const;		bool operator<(const Polygon &p) const;		bool operator!=(const Polygon &p) const;		bool operator>(const Polygon &p) const;	};				inline short Polygon::NumVertices() const	{		if (mpVertex.Size() == 0)			return -1;		else			return mpVertex.Size();	}				inline short Polygon::NumNeighbors() const 	{		return mpVertex.Size();	}				inline short Polygon::NumEdges() const	{		return mpVertex.Size();	}					inline Polygon::Polygon()	{		AllocateVertexArray();				return;	}				inline void Polygon::GetFace(short index, Array<Vertex*> &pV) const	{		pV.SetSize(2);				pV[0] = PV(index);				pV[1] = PV((index + 1) % NumVertices());				return;	}				inline short Polygon::EdgeIndex(const Vertex *pV0, const Vertex *pV1) const	{		return FaceIndex(pV0, pV1);	}				inline short Polygon::FaceIndex(const Vertex *pV0, const Vertex *pV1, const Vertex *pV2) const	{		ThrowException("Polygon::FaceIndex : not implemented");		return -1;	}		    inline void Polygon::GetEdge(short index, Vertex *pV[2]) const    {		pV[0] = PV(index);			if (index == NumVertices() - 1)			pV[1] = PV(0);		else			pV[1] = PV(index + 1);				        return;    }				inline void Polygon::FaceArea(Array<double> &faceArea) const	{		faceArea.SetSize(NumVertices());				Vertex *pV[2];		for (short i = 0; i < NumVertices(); ++i) {			GetEdge(i, pV);			faceArea[i] = pV[0]->DistanceToPoint(pV[1]);		}				return;	}				inline void Polygon::AreaNormal(Point &areaNormal) const	{		ThrowException("Polygon::GetEdge : not implemented");				return;	}	inline double Polygon::Volume() const	{		return Area();	}		    inline void Polygon::MakeListIterator(void *pListIterator)    {        if (mpListIterator != NULL)             ThrowException("Polygon::MakeListIterator : already on a list");                        std::list<Polygon>::iterator *pLi = new std::list<Polygon>::iterator;        *pLi = *(std::list<Polygon>::iterator *) pListIterator;        mpListIterator = (std::list<Polygon>::iterator *) pLi;        return;    }                        inline void Polygon::DeleteListIterator()    {        delete ((std::list<Polygon>::iterator *) mpListIterator);        return;    }}#endif // _polygon_h_