/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #ifndef _brick_h_#define _brick_h_#include "element.h"namespace NAMESPACE {	class Brick : public Element {	public:		Brick(void);        ~Brick(void) {DeleteListIterator();};                		// type		ElementType Type(void) const{return BRICK;};		short NumVertices(void) const {return 8;};				// neighbors		short NumNeighbors(void) const {return 6;};				// list iterator		void MakeListIterator(void *pListIterator);        void DeleteListIterator(void);                		// edges		short NumEdges(void) const {return 12;};		void GetEdge(short index, Vertex *pV[2]) const;		short EdgeIndex(const Vertex *pV0, const Vertex *pV1) const;				// faces		void GetFace(short index, Array<Vertex*> &pV) const;		short FaceIndex(const Vertex *pV0, const Vertex *pV1 = NULL, const Vertex *pV2 = NULL) const;				// geometry		double Volume(void) const;        double Area(void) const;        void FaceArea(Array<double> &faceArea) const;        short Dimension(void) const {return 3;};		// operators needed by STL		bool operator==(const Brick &b) const;		bool operator<(const Brick &b) const;		bool operator!=(const Brick &b) const;		bool operator>(const Brick &b) const;	};				inline Brick::Brick()	{		AllocateVertexArray();		return;	}				inline void Brick::GetEdge(short index, Vertex *pV[2]) const	{		ThrowException("Brick::GetEdge : not implemented");				switch (index) {		case 0:			pV[0] = PV(0);			pV[1] = PV(1);			break;					case 1:			pV[0] = PV(0);			pV[1] = PV(2);			break;					case 2:			pV[0] = PV(0);			pV[1] = PV(3);			break;					case 3:			pV[0] = PV(1);			pV[1] = PV(2);			break;					case 4:			pV[0] = PV(1);			pV[1] = PV(3);			break;					case 5:			pV[0] = PV(2);			pV[1] = PV(3);			break;				default:			ThrowException("Brick::GetEdge : bad index");			break;			}				return;	}				inline short Brick::EdgeIndex(const Vertex *pV0, const Vertex *pV1) const	{		ThrowException("Brick::EdgeIndex : not implemented");		short i0 = WhichVertex(pV0);		short i1 = WhichVertex(pV1);				if ((i0 == i1) || (i0 == -1) || (i1 == -1))			return -1;				if (i0 > i1)			std::swap(i0, i1);				// this trick happens to work with the edge numbering above		if (i0 == 0) 			return i1 - 1;				if (i0 == 1)			return i1 + 1;				return 5;	}				inline void Brick::GetFace(short index, Array<Vertex*> &pV) const	{		// faces are defined here so that right hand rule		// results in outward pointing normal				pV.SetSize(4);		        switch (index) {        case 0:            pV[0] = PV(0);            pV[1] = PV(3);            pV[2] = PV(2);            pV[3] = PV(1);            break;                case 1:            pV[0] = PV(0);            pV[1] = PV(1);            pV[2] = PV(5);            pV[3] = PV(4);            break;                case 2:            pV[0] = PV(1);            pV[1] = PV(2);            pV[2] = PV(6);            pV[3] = PV(5);            break;                case 3:            pV[0] = PV(2);            pV[1] = PV(3);            pV[2] = PV(7);            pV[3] = PV(6);            break;                 case 4:            pV[0] = PV(0);            pV[1] = PV(4);            pV[2] = PV(7);            pV[3] = PV(3);            break;                     case 5:            pV[0] = PV(4);            pV[1] = PV(5);            pV[2] = PV(6);            pV[3] = PV(7);            break;                    default:            ThrowException("Brick::Face : bad face index");            break;        }        		return;	}				inline void Brick::MakeListIterator(void *pListIterator)	{        if (mpListIterator != NULL)             ThrowException("Brick::MakeListIterator : already on a list");                        std::list<Brick>::iterator *pLi = new std::list<Brick>::iterator;        *pLi = *(std::list<Brick>::iterator *) pListIterator;        mpListIterator = (std::list<Brick>::iterator *) pLi;		return;	}                        inline void Brick::DeleteListIterator()    {        delete ((std::list<Brick>::iterator *) mpListIterator);        return;    }}#endif // _brick_h_