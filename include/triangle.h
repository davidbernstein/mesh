/* * Copyright (C) 2004-2018 David Bernstein <david.h.bernstein@gmail.com> * * This file is part of Mesh. * * Mesh is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * Mesh is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with Mesh.  If not, see <http://www.gnu.org/licenses/>.*/ #ifndef _triangle_h_#define _triangle_h_#include "element.h"namespace NAMESPACE {	class Triangle : public Element {	public:		// constructors		Triangle(void);        ~Triangle(void) {DeleteListIterator();};				// type		ElementType Type(void) const {return TRIANGLE;};		short NumVertices(void) const {return 3;};				// neighbors		short NumNeighbors(void) const {return 3;};				// bisection		void Bisect(Element *pChild[2], Vertex *pVNew);        Vertex* Merge(Element *pSibling, Element *pParent);				// edges		short NumEdges(void) const {return 3;};		void GetEdge(short index, Vertex *pV[2]) const;		short EdgeIndex(const Vertex *pV0, const Vertex *pV1) const; 		Vertex* EdgeMidPoint(short index) const;				// faces		void GetFace(short index, Array<Vertex*> &pV) const;		short FaceIndex(const Vertex *pV0, const Vertex *pV1 = NULL, const Vertex *pV2 = NULL) const;				// list iterator		void MakeListIterator(void *pListIterator);		void DeleteListIterator(void);                		// geometry		double Area(void) const;		double Volume(void) const;        bool ContainsPoint(const Point &p) const;        void FaceArea(Array<double> &faceArea) const;        void OutwardAreaNormal(Array<Point> &unitNormal) const;        void AreaNormal(Point &areaNormal) const;        short Dimension(void) const {return 2;};				// operators needed by STL		bool operator==(const Triangle &t) const;		bool operator<(const Triangle &t) const;		bool operator!=(const Triangle &t) const;		bool operator>(const Triangle &t) const;	};					inline Triangle::Triangle()	{		AllocateVertexArray();				return;	}				inline void Triangle::GetFace(short index, Array<Vertex*> &pV) const	{		// faces are stored in the following order:		// face[0] is opposite to vertex 0		// face[1] is opposite to vertex 1		// face[2] is opposite to vertex 2				pV.SetSize(2);		        switch (index) {        case 0:            pV[0] = PV(1);            pV[1] = PV(2);            break;                case 1:            pV[0] = PV(2);            pV[1] = PV(0);            break;                case 2:            pV[0] = PV(0);            pV[1] = PV(1);            break;                default:            ThrowException("Triangle::GetFace : bad face index");            break;        }        		return;	}				inline short Triangle::EdgeIndex(const Vertex *pV0, const Vertex *pV1) const	{		return FaceIndex(pV0, pV1);	}				inline short Triangle::FaceIndex(const Vertex *pV0, const Vertex *pV1, const Vertex *pV2) const	{		short i0 = WhichVertex(pV0);		if (i0 == -1)			return -1;					short i1 = WhichVertex(pV1);		if (i1 == -1)			return -1;				if (i0 == i1)			return -1;				switch (i0) {		case 0:			if (i1 == 1)				return 2;			else 				return 1;						break;					case 1:			if (i1 == 0)				return 2;			else 				return 0;						break;				case 2:			if (i1 == 1)				return 0;			else 				return 1;						break;		}					// should never get here		ThrowException("Triangle::FaceIndex : can't get here");		return -1;	}		    inline void Triangle::GetEdge(short index, Vertex *pV[2]) const    {        switch (index) {        case 0:            pV[0] = PV(1);            pV[1] = PV(2);            break;			        case 1:            pV[0] = PV(2);            pV[1] = PV(0);            break;			        case 2:            pV[0] = PV(0);            pV[1] = PV(1);            break;				        default:            ThrowException("Triangle::GetEdge : bad index");            break;        }		        return;    }				inline void Triangle::AreaNormal(Point &areaNormal) const	{		Point p01 = *PV(1) - *PV(0);		Point p02 = *PV(2) - *PV(0);			areaNormal = (p01.Cross(p02)) * 0.5;				return;	}		inline double Triangle::Area() const	{		Point areaNormal;		AreaNormal(areaNormal);		return areaNormal.Norm();	}	inline double Triangle::Volume() const	{		// volume is interpreted as the volume of a prism with		// this triangle as base and unit height		return Area();	}		    inline void Triangle::MakeListIterator(void *pListIterator)    {        if (mpListIterator != NULL)             ThrowException("Triangle::MakeListIterator : already on a list");                        std::list<Triangle>::iterator *pLi = new std::list<Triangle>::iterator;        *pLi = *(std::list<Triangle>::iterator *) pListIterator;        mpListIterator = (std::list<Triangle>::iterator *) pLi;        return;    }                        inline void Triangle::DeleteListIterator()    {        delete ((std::list<Triangle>::iterator *) mpListIterator);        return;    }}#endif // _triangle_h_